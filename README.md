# 1. Complexity_17
Group assignment of group 17 for the 2026 Complexity course at the University of Amsterdam. The main topic explored is the training of Neural Cellular Automata (NCA), their capacity for emergence of complex shapes, and testing their resilience against perturbations

# 2. Project Description
This project sought to use Neural Cellular Automata (NCA) to study self-organization of cells containing the same “instructions” (DNA/neural network). The main focus was on seeing if individual cells can spatialy organize themselves into some complex predefined pattern, much like cell differentiation in living beings. To generate the 'instructions' we initially tried using an Evolutionary Algorithm, however due to undesired results and the limited time frame of this project (2 weeks), we pivotted to using backpropagation and the updating-scheme described by Morsidiv et. al., (2020).

After training some weights for a variety of target patterns (e.g., star or amongus character) we analyzed the regenerative properties of these NCA by applying two different types of damage.
1. A random damage mask, where random cells on the grid were deleted.
2. A circular 'blob' damage mask, where a specific chunk of damage was done on a random part of the grid.

Our main observations are twofold; 1) for simple target patterns, we can clearly distinguish a human readable pattern in the state-vector of the grid resembling on a high-level how cell differentiation occurs in living beings; 2) trained NCA are more vulnurable to damage being done in 'blobs' (deleting a whole chunk of the grid at once), than when a random damage mask is applied on the grid.

# 3. Repository Layout / Files
__data/__
- MCAF/ -> contains .csv files that were generated for testing how random damage and blob damage affected trained NCA.
- states/ -> (DEPRECATED) is used for storing the state of a specific EA run for later continuation.
- targets/ -> contains images that were converted to target grids for training the NCA weights through backpropagation.

__slides/__
- contains the presentation slides

__src/__
- ea.py -> (DEPRECATED) used for running an evolutionary algorithm (EA) that optimizes the weights of an NCA
- fitness_plot.py -> (DEPRECATED) used for creating a fitness plot for specific EA runs.
- grid.py -> contains the Grid class which is used for storing (pools of) grids and running NCA simulations on them.
- main.py -> (DEPRECATED) initially used for testing different parts of the project
- mcaf.py -> simulates the destruction of the grid and generates the data used in the presentation. Use --help to find out CLI use.
- nn.py -> contains the NN class that is used as the 'update rule' for NCA.
- plot_mcaf.py -> plots the data generated by src/mcaf.py. Use --help to find out CLI use.
- plotting.py -> contains two functions to plot or animate heatmaps of gridstates.
- train.py -> used for training an NN 'update rule' for NCA for some target pattern through backpropagation. 
- ui_with_grid.py -> launches a UI to load weights and simulate NCA in real time.
- utils.py -> utility file containing general functions and variables for loading and reading weights and images. Can be run to test out the image loading functionality.

__weights/__
- contains weight files that were trained through either the EA or backpropagation and can be loaded for the UI

# 4. Dependencies
This project uses Astral UV as a Python package and project manager. After cloning the repository one can initialize a virtual environment as:
```bash
uv venv
```
Then run the following terminal command to sync the dependencies of this project with your local environment:
```bash
uv sync
```

## 4.1. Example Usage (UI)
Once the required dependencies are installed you can run the following command to open up the UI.
```bash
uv run src/ui_with_grid.py
```

Here one can then select weights from the weights folder (e.g., 'Gr50-Ch8-Hi64_star.pt') and press play. 

https://github.com/user-attachments/assets/0dfb7f9e-df98-4bb9-80d8-43914bcf99f3

Interacting in real time with grid can be done in two ways:
1. Erasing real time using left-mouse click on grid and dragging
2. Seeding real time using right-mouse click on grid and dragging

The UI allows for varying methods of measurment/analysis:
1. visual analysis of the effects of layers on the whole(shape) through the "show hidden layers" button.
2. implementing and adding your own analysis tool (for example real time spacial entropy or langtons parameter calculations) - after defining your analysis function this can be added to the UI by adding it to the "analysis_tool" dictionary with structure: {Key (Name of the tool as shown in the combobox) : Value  (A function that takes the current grid as input and returns a float or string to be displayed in the analysis tool label.)}

## 4.2. Example Usage (Training)
The training script (`src/train.py`) trains an NCA update rule (`NN`) to grow toward a target pattern using backpropagation and a persistent pool of grid states. Each iteration samples a random batch from the pool, optionally damages the best-performing samples to encourage robustness, reseeds the worst sample, evolves the batch for a random number of steps, computes MSE loss on the alpha channel, and updates the network weights.

Configuration:
Training settings are currently adjusted in `main()` inside `src/train.py` (e.g., `target_pattern`, number of iterations, step range, learning rate, pool/batch size, and damage settings). To train on a custom image target, place it in `data/targets/` and update the `load_target_image(...)` path in `main()`.

Run training:
```bash
uv run src/train.py
```

Outputs:
- A timestamped folder is created in `training/` containing `loss.csv` and optional plotted figures (if `plot_steps` is enabled).
- Whenever a new best model is found, the weights are saved to `weights/` (filename includes grid size, channels, hidden size, and timestamp).



## 4.3. Example Usage (Grid API)
The `Grid` class (`src/grid.py`) stores a pool of grid states and evolves a selected batch of them efficiently on GPU.

Typical usage:
1) `grid = Grid(...)`
2) `grid.set_batch([...pool indices...])`
3) `grid.load_batch_from_pool()`
4) `grid.run_simulation_batch(steps, update_prob, masking_th)`
5) `grid.write_batch_back_to_pool()`

Each grid state has shape `(C, H, W)` and the batch has shape `(B, C, H, W)`. `update_prob` controls stochastic cell updates, and `masking_th` controls the alive mask threshold based on the alpha channel.


# 5. References
This project was heavilly inspired by the following wonderfull paper.

__Mordvintsev, et al., "Growing Neural Cellular Automata", Distill, 2020__ -> [Link](https://distill.pub/2020/growing-ca/)

We highly recommend you to check it out.
